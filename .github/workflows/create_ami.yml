name: Publish AMI

on:
  workflow_call:
    inputs:
      image_tag:
        description: "Tag de la imagen en GHCR (ej: latest, v1.2.3)"
        required: true
        type: string
      ami_name_override:
        description: "Nombre AMI opcional (si no se define, se genera por defecto)"
        required: false
        type: string
      force_ami_creation:
        description: "Forzar creaciÃ³n de AMI aunque ya exista"
        required: false
        type: boolean
        default: false
      update_running_instances:
        description: "Actualizar instancias EC2 corriendo con la nueva AMI"
        required: false
        type: boolean
        default: false
    secrets:
      # AWS
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      AWS_REGION:
        required: true
      AWS_S3_BUCKET:
        required: true
      # Red Hat registry (para pull de rhel9/bootc-image-builder)
      SOURCE_REGISTRY_USER:
        required: true
      SOURCE_REGISTRY_PASSWORD:
        required: true
      # GITHUB_TOKEN se hereda con `secrets: inherit` desde el caller
      # Opcional: para actualizar instancias EC2
      EC2_INSTANCE_IDS:
        required: false
        description: "Lista de instance IDs separados por coma para actualizar"

jobs:
  check-ami-exists:
    name: Check if AMI already exists
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      ami_exists: ${{ steps.check-ami.outputs.ami_exists }}
      existing_ami_id: ${{ steps.check-ami.outputs.ami_id }}
      ami_name: ${{ steps.vars.outputs.ami_name }}

    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      REPO_OWNER: ${{ github.repository_owner }}
      REPO_NAME: ${{ github.event.repository.name }}
      IMAGE_TAG: ${{ inputs.image_tag }}
      AMI_NAME_PREFIX: ${{ vars.AMI_NAME_PREFIX }}

    steps:
      - name: Preparar variables AMI
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ inputs.ami_name_override }}" ]; then
            AMI_NAME="${{ inputs.ami_name_override }}"
          elif [ -n "${AMI_NAME_PREFIX:-}" ]; then
            AMI_NAME="${AMI_NAME_PREFIX}-${IMAGE_TAG}-${GITHUB_RUN_NUMBER}"
          else
            AMI_NAME="${REPO_NAME}-${IMAGE_TAG}-${GITHUB_RUN_NUMBER}"
          fi
          echo "ami_name=$AMI_NAME" >> $GITHUB_OUTPUT
          echo "AMI name to check: $AMI_NAME"

      - name: Check if AMI exists
        id: check-ami
        run: |
          echo "Checking if AMI '${{ steps.vars.outputs.ami_name }}' exists..."
          
          # Search for AMI by name
          AMI_INFO=$(aws ec2 describe-images \
            --owners self \
            --filters "Name=name,Values=${{ steps.vars.outputs.ami_name }}" \
            --query 'Images[0].[ImageId,State]' \
            --output text \
            --region "${AWS_REGION}" || echo "None None")
          
          AMI_ID=$(echo $AMI_INFO | cut -d' ' -f1)
          AMI_STATE=$(echo $AMI_INFO | cut -d' ' -f2)
          
          if [ "$AMI_ID" != "None" ] && [ "$AMI_STATE" = "available" ]; then
            echo "âœ… AMI already exists: $AMI_ID" >> $GITHUB_STEP_SUMMARY
            echo "ami_exists=true" >> $GITHUB_OUTPUT
            echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
          else
            echo "âŒ AMI does not exist or is not available" >> $GITHUB_STEP_SUMMARY
            echo "ami_exists=false" >> $GITHUB_OUTPUT
            echo "ami_id=" >> $GITHUB_OUTPUT
          fi

  build-ami:
    name: Build & Register AMI (RHEL bootc-image-builder)
    runs-on: ubuntu-latest
    needs: check-ami-exists
    if: needs.check-ami-exists.outputs.ami_exists == 'false' || inputs.force_ami_creation == true
    permissions:
      contents: read
    outputs:
      ami_id: ${{ steps.extract-ami-id.outputs.ami_id }}
      ami_name: ${{ needs.check-ami-exists.outputs.ami_name }}

    env:
      DEST_REGISTRY_HOST: ghcr.io
      REPO_OWNER: ${{ github.repository_owner }}
      REPO_NAME: ${{ github.event.repository.name }}
      IMAGE_TAG: ${{ inputs.image_tag }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_DEFAULT_REGION: ${{ secrets.AWS_REGION }}
      AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
      AMI_NAME_PREFIX: ${{ vars.AMI_NAME_PREFIX }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preparar variables para build
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          SRC_IMAGE="ghcr.io/${REPO_OWNER}/${REPO_NAME}:${IMAGE_TAG}"
          AMI_NAME="${{ needs.check-ami-exists.outputs.ami_name }}"
          
          echo "src_image=$SRC_IMAGE" >> $GITHUB_OUTPUT
          echo "ami_name=$AMI_NAME" >> $GITHUB_OUTPUT
          echo "Usando imagen: $SRC_IMAGE"
          echo "Nombre AMI:   $AMI_NAME"
          
          if [ "${{ inputs.force_ami_creation }}" == "true" ]; then
            echo "âš ï¸ Forzando creaciÃ³n de AMI (sobreescribiendo existente)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ… Creando nueva AMI" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Install Podman and container tools
        run: |
          # Update package lists
          sudo apt-get update
          
          # Install podman from official repository
          sudo apt-get install -y podman containernetworking-plugins
          
          # Verify installation
          podman --version
          echo "âœ… Podman installed successfully" >> $GITHUB_STEP_SUMMARY

      - name: Setup container storage and authentication
        run: |
          # Create directories for container storage (both root and user)
          sudo mkdir -p /etc/containers
          mkdir -p $HOME/.config/containers
          mkdir -p $HOME/.local/share/containers
          
          # Setup containers.conf for rootful mode (bootc-image-builder requirement)
          sudo tee /etc/containers/containers.conf << 'EOF'
          [containers]
          default_ulimits = []
          pids_limit = 0

          [engine]
          cgroup_manager = "systemd"
          events_logger = "journald"
          runtime = "crun"
          EOF
          
          # Also setup user config as fallback
          cat > $HOME/.config/containers/containers.conf << 'EOF'
          [containers]
          default_ulimits = []
          pids_limit = 0

          [engine]
          cgroup_manager = "systemd"
          events_logger = "journald"
          runtime = "crun"
          EOF

      - name: Login to registries
        run: |
          # Ensure auth directories exist (both root and user)
          sudo mkdir -p /root/.config/containers
          mkdir -p $HOME/.config/containers
          
          echo "Logging into GitHub Container Registry (rootful)..."
          echo "${{ secrets.GITHUB_TOKEN }}" | sudo podman login ghcr.io -u ${{ github.actor }} --password-stdin --authfile /root/.config/containers/auth.json
          
          echo "Logging into Red Hat Registry (rootful)..."
          echo "${{ secrets.SOURCE_REGISTRY_PASSWORD }}" | sudo podman login registry.redhat.io -u "${{ secrets.SOURCE_REGISTRY_USER }}" --password-stdin --authfile /root/.config/containers/auth.json
          
          # Also login for user (fallback)
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ghcr.io -u ${{ github.actor }} --password-stdin --authfile $HOME/.config/containers/auth.json
          echo "${{ secrets.SOURCE_REGISTRY_PASSWORD }}" | podman login registry.redhat.io -u "${{ secrets.SOURCE_REGISTRY_USER }}" --password-stdin --authfile $HOME/.config/containers/auth.json
          
          echo "âœ… Successfully logged into both registries (rootful and rootless)" >> $GITHUB_STEP_SUMMARY

      - name: Validate credentials and test authentication
        run: |
          if [ -z "${{ secrets.SOURCE_REGISTRY_USER }}" ] || [ -z "${{ secrets.SOURCE_REGISTRY_PASSWORD }}" ]; then
            echo "âŒ Red Hat registry credentials missing" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ”§ How to fix this:" >> $GITHUB_STEP_SUMMARY
            echo "1. Go to your GitHub repository Settings â†’ Secrets and variables â†’ Actions" >> $GITHUB_STEP_SUMMARY
            echo "2. Add these secrets:" >> $GITHUB_STEP_SUMMARY
            echo "   - \`SOURCE_REGISTRY_USER\`: Your Red Hat Customer Portal username" >> $GITHUB_STEP_SUMMARY
            echo "   - \`SOURCE_REGISTRY_PASSWORD\`: Your Red Hat Customer Portal password" >> $GITHUB_STEP_SUMMARY
            echo "3. Make sure you have a valid Red Hat subscription" >> $GITHUB_STEP_SUMMARY
            echo "4. Test your credentials at: https://access.redhat.com/RegistryAuthentication" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          # Test authentication by trying to get login info
          echo "Testing Red Hat registry authentication..."
          if sudo podman login --get-login registry.redhat.io >/dev/null 2>&1; then
            echo "âœ… Red Hat registry authentication successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Red Hat registry authentication failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ”§ Troubleshooting Steps:" >> $GITHUB_STEP_SUMMARY
            echo "1. **Check credentials**: Verify SOURCE_REGISTRY_USER and SOURCE_REGISTRY_PASSWORD in GitHub Secrets" >> $GITHUB_STEP_SUMMARY
            echo "2. **Verify subscription**: Ensure you have an active Red Hat subscription" >> $GITHUB_STEP_SUMMARY
            echo "3. **Test manually**: Try \`podman login registry.redhat.io\` with your credentials" >> $GITHUB_STEP_SUMMARY
            echo "4. **Check account**: Visit https://access.redhat.com/management/subscriptions" >> $GITHUB_STEP_SUMMARY
            echo "5. **Password vs Token**: Use your Customer Portal password, not an API token" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Pull bootc-image-builder
        run: |
          echo "Pulling bootc-image-builder..."
          if sudo podman pull registry.redhat.io/rhel9/bootc-image-builder:latest; then
            echo "âœ… Successfully pulled bootc-image-builder" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Failed to pull bootc-image-builder - authentication failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ’¡ Most Common Causes:" >> $GITHUB_STEP_SUMMARY
            echo "1. **Invalid Credentials**: Check that your Red Hat Customer Portal username/password are correct" >> $GITHUB_STEP_SUMMARY
            echo "2. **Expired Subscription**: Ensure your Red Hat subscription is active" >> $GITHUB_STEP_SUMMARY
            echo "3. **Account Issues**: Your account may need to accept new terms at https://access.redhat.com" >> $GITHUB_STEP_SUMMARY
            echo "4. **Wrong Registry**: Make sure you're using registry.redhat.io, not other Red Hat registries" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

      - name: Prepare authentication for bootc-image-builder
        run: |
          # Verify root auth.json exists and contains credentials (primary)
          if [ ! -f "/root/.config/containers/auth.json" ]; then
            echo "âŒ Root auth file not found: /root/.config/containers/auth.json" >> $GITHUB_STEP_SUMMARY
            
            # Fallback to user auth.json
            if [ ! -f "$HOME/.config/containers/auth.json" ]; then
              echo "âŒ User auth file also not found: $HOME/.config/containers/auth.json" >> $GITHUB_STEP_SUMMARY
              exit 1
            else
              AUTH_FILE="$HOME/.config/containers/auth.json"
              echo "âš ï¸ Using user auth file as fallback" >> $GITHUB_STEP_SUMMARY
            fi
          else
            AUTH_FILE="/root/.config/containers/auth.json"
            echo "âœ… Using root auth file" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Verify auth.json contains both registries
          if ! sudo grep -q "ghcr.io" "$AUTH_FILE"; then
            echo "âŒ GitHub Container Registry credentials missing from auth.json" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          if ! sudo grep -q "registry.redhat.io" "$AUTH_FILE"; then
            echo "âŒ Red Hat Registry credentials missing from auth.json" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          # Create a temporary directory for container auth
          mkdir -p /tmp/container-auth
          
          # Copy the auth file to a location the container can access
          sudo cp "$AUTH_FILE" /tmp/container-auth/auth.json
          sudo chmod 644 /tmp/container-auth/auth.json
          
          echo "âœ… Authentication files prepared and verified for container" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“‹ Auth file contains credentials for both registries" >> $GITHUB_STEP_SUMMARY

      - name: Create AMI with bootc-image-builder
        id: create-ami
        run: |
          echo "ðŸš€ Iniciando creaciÃ³n de AMI..." >> $GITHUB_STEP_SUMMARY
          
          # Validate source image has proper tag
          SRC_IMAGE="${{ steps.vars.outputs.src_image }}"
          if [[ "$SRC_IMAGE" == *":" ]]; then
            echo "âŒ Source image has empty tag: $SRC_IMAGE" >> $GITHUB_STEP_SUMMARY
            echo "IMAGE_TAG was: '${IMAGE_TAG}'" >> $GITHUB_STEP_SUMMARY
            # Use 'latest' as fallback
            SRC_IMAGE="${SRC_IMAGE}latest"
            echo "ðŸ”§ Using fallback tag 'latest': $SRC_IMAGE" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "ðŸ“‹ Building AMI from: $SRC_IMAGE" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“‹ AMI Name: ${{ steps.vars.outputs.ami_name }}" >> $GITHUB_STEP_SUMMARY
          
          # Pull the source image first (bootc-image-builder no longer pulls automatically)
          echo "ðŸ”„ Pulling source image: $SRC_IMAGE"
          if sudo podman pull "$SRC_IMAGE"; then
            echo "âœ… Source image pulled successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Failed to pull source image: $SRC_IMAGE" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ”§ Troubleshooting:" >> $GITHUB_STEP_SUMMARY
            echo "1. **Check image exists**: Verify the image was built and pushed in previous workflow" >> $GITHUB_STEP_SUMMARY
            echo "2. **Check registry access**: Ensure GitHub Container Registry credentials are valid" >> $GITHUB_STEP_SUMMARY
            echo "3. **Check tag**: Verify the image tag '$IMAGE_TAG' exists" >> $GITHUB_STEP_SUMMARY
            echo "4. **Manual check**: Visit https://github.com/${{ github.repository_owner }}/${{ github.event.repository.name }}/pkgs/container/${{ github.event.repository.name }}" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          # Run bootc-image-builder with proper authentication and storage mounts (rootful)
          set +e  # Don't exit on error, we want to capture it
          sudo podman run \
            --rm \
            --privileged \
            --security-opt label=type:unconfined_t \
            -v /var/lib/containers/storage:/var/lib/containers/storage \
            -v /tmp/container-auth/auth.json:/run/containers/0/auth.json:ro \
            -e AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}" \
            -e AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}" \
            -e AWS_REGION="${AWS_REGION}" \
            -e AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION}" \
            registry.redhat.io/rhel9/bootc-image-builder:latest \
              --type ami \
              --aws-ami-name "${{ steps.vars.outputs.ami_name }}" \
              --aws-bucket "${AWS_S3_BUCKET}" \
              --aws-region "${AWS_REGION}" \
              "$SRC_IMAGE" \
            2>&1 | tee ami-creation.log
          
          EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… AMI creation process completed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ AMI creation failed with exit code $EXIT_CODE" >> $GITHUB_STEP_SUMMARY
            echo "Check ami-creation.log for details" >> $GITHUB_STEP_SUMMARY
            cat ami-creation.log
            exit $EXIT_CODE
          fi

      - name: Extract AMI ID from logs
        id: extract-ami-id
        run: |
          # Wait a moment for AWS to register the AMI
          sleep 10
          
          AMI_ID=$(aws ec2 describe-images \
            --owners self \
            --filters "Name=name,Values=${{ steps.vars.outputs.ami_name }}" \
            --query 'Images[0].ImageId' \
            --output text \
            --region "${AWS_REGION}")
          
          if [ "$AMI_ID" != "None" ] && [ "$AMI_ID" != "null" ] && [ -n "$AMI_ID" ]; then
            echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
            echo "âœ… AMI created successfully: $AMI_ID" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ Could not find created AMI after creation process" >> $GITHUB_STEP_SUMMARY
            echo "AMI name searched: ${{ steps.vars.outputs.ami_name }}" >> $GITHUB_STEP_SUMMARY
            echo "This indicates the AMI creation failed" >> $GITHUB_STEP_SUMMARY
            echo "ami_id=" >> $GITHUB_OUTPUT
            exit 1
          fi

  update-running-instances:
    name: Update Running EC2 Instances
    runs-on: ubuntu-latest
    needs: [check-ami-exists, build-ami]
    if: always() && inputs.update_running_instances == true && (needs.build-ami.outputs.ami_id != '' || needs.check-ami-exists.outputs.existing_ami_id != '')
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
    
    steps:
      - name: Determine AMI to use
        id: determine-ami
        run: |
          if [ -n "${{ needs.build-ami.outputs.ami_id }}" ]; then
            AMI_ID="${{ needs.build-ami.outputs.ami_id }}"
            echo "Using newly created AMI: $AMI_ID"
          else
            AMI_ID="${{ needs.check-ami-exists.outputs.existing_ami_id }}"
            echo "Using existing AMI: $AMI_ID"
          fi
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT

      - name: Find instances to update
        id: find-instances
        run: |
          echo "## EC2 Instance Update Process" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ secrets.EC2_INSTANCE_IDS }}" ]; then
            # Use provided instance IDs
            INSTANCE_IDS="${{ secrets.EC2_INSTANCE_IDS }}"
            echo "Using provided instance IDs: $INSTANCE_IDS"
          else
            # Find running instances with the previous AMI version
            # This is a simplified approach - in production you'd want more sophisticated filtering
            INSTANCE_IDS=$(aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" \
                        "Name=tag:Project,Values=rhel-bootc-demo" \
              --query 'Reservations[].Instances[].InstanceId' \
              --output text \
              --region "${AWS_REGION}" | tr '\t' ',')
            
            if [ -z "$INSTANCE_IDS" ]; then
              echo "No instances found with Project=rhel-bootc-demo tag"
              INSTANCE_IDS=""
            fi
          fi
          
          echo "instance_ids=$INSTANCE_IDS" >> $GITHUB_OUTPUT
          echo "Instance IDs to update: $INSTANCE_IDS" >> $GITHUB_STEP_SUMMARY

      - name: Perform bootc upgrade on running instances
        if: steps.find-instances.outputs.instance_ids != ''
        run: |
          IFS=',' read -ra INSTANCES <<< "${{ steps.find-instances.outputs.instance_ids }}"
          
          echo "### Instance Update Results:" >> $GITHUB_STEP_SUMMARY
          
          for INSTANCE_ID in "${INSTANCES[@]}"; do
            if [ -n "$INSTANCE_ID" ]; then
              echo "ðŸ”„ Updating instance: $INSTANCE_ID"
              
              # Get instance public IP for SSH connection
              PUBLIC_IP=$(aws ec2 describe-instances \
                --instance-ids "$INSTANCE_ID" \
                --query 'Reservations[0].Instances[0].PublicIpAddress' \
                --output text \
                --region "${AWS_REGION}")
              
              if [ "$PUBLIC_IP" != "None" ] && [ -n "$PUBLIC_IP" ]; then
                echo "ðŸ“ Instance $INSTANCE_ID has public IP: $PUBLIC_IP"
                
                # Create bootc upgrade script
                NEW_IMAGE="ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ inputs.image_tag }}"
                
                # Write bootc upgrade script directly
                echo '#!/bin/bash' > bootc-upgrade.sh
                echo 'set -euo pipefail' >> bootc-upgrade.sh
                echo '' >> bootc-upgrade.sh  
                echo "echo 'ðŸš€ Starting bootc upgrade to: $NEW_IMAGE'" >> bootc-upgrade.sh
                echo '' >> bootc-upgrade.sh
                echo "sudo bootc switch '$NEW_IMAGE'" >> bootc-upgrade.sh
                echo '' >> bootc-upgrade.sh
                echo 'sudo bootc status' >> bootc-upgrade.sh
                echo '' >> bootc-upgrade.sh
                echo 'echo "âœ… Bootc upgrade staged. Reboot required to activate."' >> bootc-upgrade.sh
                echo "echo 'Current staged image: $NEW_IMAGE'" >> bootc-upgrade.sh
                
                chmod +x bootc-upgrade.sh

                # Note: In a real scenario, you'd need SSH access configured
                # This is a placeholder showing the concept
                echo "ðŸ“ Bootc upgrade script prepared for $INSTANCE_ID" >> $GITHUB_STEP_SUMMARY
                echo "âš ï¸ Manual step required: Execute bootc-upgrade.sh on instance $INSTANCE_ID" >> $GITHUB_STEP_SUMMARY
                echo "ðŸ’¡ SSH command: ssh bootc-user@$PUBLIC_IP 'bash -s' < bootc-upgrade.sh" >> $GITHUB_STEP_SUMMARY
                
                # Alternative: Use SSM if instances have SSM agent
                echo "ðŸ”§ Attempting SSM command execution..."
                SSM_IMAGE="ghcr.io/${{ github.repository_owner }}/${{ github.event.repository.name }}:${{ inputs.image_tag }}"
                aws ssm send-command \
                  --instance-ids "$INSTANCE_ID" \
                  --document-name "AWS-RunShellScript" \
                  --parameters "commands=[
                    \"sudo bootc switch $SSM_IMAGE\",
                    \"sudo bootc status\",
                    \"echo 'Bootc upgrade staged. Reboot to activate.'\"
                  ]" \
                  --region "${AWS_REGION}" || {
                    echo "âš ï¸ SSM command failed for $INSTANCE_ID - manual intervention required" >> $GITHUB_STEP_SUMMARY
                  }
                
              else
                echo "âŒ Instance $INSTANCE_ID has no public IP" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ”„ **Bootc Update Process:**" >> $GITHUB_STEP_SUMMARY
          echo "1. âœ… New image staged on instances with \`bootc switch\`" >> $GITHUB_STEP_SUMMARY
          echo "2. â³ **Manual step**: Reboot instances to activate new image" >> $GITHUB_STEP_SUMMARY
          echo "3. ðŸ” Verify with \`bootc status\` after reboot" >> $GITHUB_STEP_SUMMARY

      - name: Schedule instance reboots (optional)
        if: steps.find-instances.outputs.instance_ids != '' && github.event_name == 'workflow_dispatch'
        run: |
          IFS=',' read -ra INSTANCES <<< "${{ steps.find-instances.outputs.instance_ids }}"
          
          echo "### Scheduled Reboots:" >> $GITHUB_STEP_SUMMARY
          
          for INSTANCE_ID in "${INSTANCES[@]}"; do
            if [ -n "$INSTANCE_ID" ]; then
              # Schedule a reboot in 5 minutes to allow bootc switch to complete
              aws ssm send-command \
                --instance-ids "$INSTANCE_ID" \
                --document-name "AWS-RunShellScript" \
                --parameters 'commands=[
                  "echo \"Scheduling reboot in 5 minutes to activate bootc upgrade...\"",
                  "sudo shutdown -r +5 \"Activating bootc upgrade - scheduled by GitHub Actions\""
                ]' \
                --region "${AWS_REGION}" || {
                  echo "âš ï¸ Could not schedule reboot for $INSTANCE_ID" >> $GITHUB_STEP_SUMMARY
                }
              
              echo "â° Reboot scheduled for $INSTANCE_ID in 5 minutes" >> $GITHUB_STEP_SUMMARY
            fi
          done

  ami-summary:
    name: AMI Creation Summary
    runs-on: ubuntu-latest
    needs: [check-ami-exists, build-ami, update-running-instances]
    if: always()
    
    steps:
      - name: AMI Process Summary
        run: |
          echo "## AMI Creation & Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          
          # AMI Check Results
          if [ "${{ needs.check-ami-exists.outputs.ami_exists }}" == "true" ]; then
            echo "| AMI Check | âœ… Found | AMI already exists: ${{ needs.check-ami-exists.outputs.existing_ami_id }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| AMI Check | âŒ Not Found | AMI needs to be created |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # AMI Creation Results
          if [ "${{ needs.build-ami.result }}" == "success" ]; then
            echo "| AMI Creation | âœ… Success | New AMI: ${{ needs.build-ami.outputs.ami_id }} |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.build-ami.result }}" == "skipped" ]; then
            echo "| AMI Creation | â­ï¸ Skipped | Using existing AMI |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| AMI Creation | âŒ Failed | Check logs for details |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Instance Update Results
          if [ "${{ needs.update-running-instances.result }}" == "success" ]; then
            echo "| Instance Update | âœ… Success | Running instances updated |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.update-running-instances.result }}" == "skipped" ]; then
            echo "| Instance Update | â­ï¸ Skipped | Not requested |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Instance Update | âŒ Failed | Check logs for details |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Final Results:" >> $GITHUB_STEP_SUMMARY
          echo "- **AMI Name**: ${{ needs.check-ami-exists.outputs.ami_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: ${{ secrets.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          
          if [ -n "${{ needs.build-ami.outputs.ami_id }}" ]; then
            echo "- **New AMI ID**: ${{ needs.build-ami.outputs.ami_id }}" >> $GITHUB_STEP_SUMMARY
          elif [ -n "${{ needs.check-ami-exists.outputs.existing_ami_id }}" ]; then
            echo "- **Existing AMI ID**: ${{ needs.check-ami-exists.outputs.existing_ami_id }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“‹ Check AWS EC2 Console for AMI availability" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ” Verify instance updates completed successfully" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”„ Monitor instance reboots if scheduled" >> $GITHUB_STEP_SUMMARY